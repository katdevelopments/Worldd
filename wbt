print("WBT Script Initialized")

local WBT_SETTINGS = {
    WebsiteBaseUrl = "https://worldbt.netlify.app",
    LogLevel = "Info",
    UseGui = true,
    AutoCopyLink = true,
}

local WBT = {}
WBT.Info = { Executor = "Unknown", Version = "N/A" }
WBT.Results = {}
WBT.Logs = {}
WBT.Stats = { Total = 0, Passed = 0 }

local function Log(level, ...)
    local message = table.concat({...}, " ")
    table.insert(WBT.Logs, {Level = level, Message = message, Time = os.time()})
    
    local levels = {Debug = 0, Info = 1, Warn = 2, Error = 3}
    if (levels[level] or 1) < (levels[WBT_SETTINGS.LogLevel] or 1) then
        return
    end

    local prefix = "[WBT " .. level:upper() .. "]"
    
    if rconsoleprint then
        local printFunc = ({
            Info = rconsoleinfo,
            Warn = rconsolewarn,
            Error = rconsoleerr,
            Debug = rconsoleprint
        })[level] or rconsoleprint
        
        pcall(printFunc, prefix, message)
    else
        if level == "Error" then
            warn(prefix, message)
        elseif level == "Warn" then
            warn(prefix, message)
        else
            print(prefix, message)
        end
    end
end

local GUI = {}
GUI.ScreenGui = nil
GUI.MainFrame = nil
GUI.StatusLabel = nil
GUI.ScoreLabel = nil

local function CreateInstance(type, properties)
    local s, obj = pcall(Instance.new, type)
    if not s or not obj then return nil end
    
    for prop, value in pairs(properties) do
        pcall(function()
            obj[prop] = value
        end)
    end
    return obj
end

function GUI:Create()
    if not WBT_SETTINGS.UseGui then return end
    
    if GUI.ScreenGui then
        GUI.ScreenGui:Destroy()
    end
    
    local parent = gethui and gethui() or game:GetService("CoreGui")
    
    GUI.ScreenGui = CreateInstance("ScreenGui", {
        Name = "WBT_Gui_" .. math.random(1e5, 1e6),
        ResetOnSpawn = false,
        Parent = parent
    })
    
    GUI.MainFrame = CreateInstance("Frame", {
        Name = "MainFrame",
        Size = UDim2.fromOffset(450, 280),
        Position = UDim2.fromScale(0.5, 0.5),
        AnchorPoint = Vector2.new(0.5, 0.5),
        BackgroundColor3 = Color3.fromRGB(20, 20, 20),
        BorderSizePixel = 0,
        Parent = GUI.ScreenGui
    })
    
    CreateInstance("UICorner", { CornerRadius = new(UDim, 0, 8), Parent = GUI.MainFrame })
    CreateInstance("UIStroke", { Color = Color3.fromRGB(80, 80, 80), Thickness = 1, Parent = GUI.MainFrame })
    CreateInstance("UIGradient", {
        Color = ColorSequence.new({
            ColorSequenceKeypoint.new(0, Color3.fromRGB(35, 35, 35)),
            ColorSequenceKeypoint.new(1, Color3.fromRGB(25, 25, 25))
        }),
        Rotation = 90,
        Parent = GUI.MainFrame
    })

    local header = CreateInstance("Frame", {
        Name = "Header",
        Size = UDim2.new(1, 0, 0, 40),
        BackgroundColor3 = Color3.fromRGB(15, 15, 15),
        BorderSizePixel = 0,
        Parent = GUI.MainFrame,
        Active = true,
        Draggable = true
    })
    
    CreateInstance("UICorner", { CornerRadius = new(UDim, 0, 8), Parent = header })
    CreateInstance("UIStroke", { Color = Color3.fromRGB(80, 80, 80), Thickness = 1, Parent = header })

    local title = CreateInstance("TextLabel", {
        Name = "Title",
        Size = UDim2.new(1, -50, 1, 0),
        Position = UDim2.fromOffset(15, 0),
        BackgroundTransparency = 1,
        Text = "WBT - World Benchmark Test",
        Font = Enum.Font.Code,
        TextColor3 = Color3.fromRGB(220, 220, 220),
        TextSize = 18,
        TextXAlignment = Enum.TextXAlignment.Left,
        Parent = header
    })
    
    local closeButton = CreateInstance("TextButton", {
        Name = "CloseButton",
        Size = UDim2.fromOffset(40, 40),
        Position = UDim2.new(1, 0, 0, 0),
        AnchorPoint = Vector2.new(1, 0),
        BackgroundTransparency = 1,
        Text = "X",
        Font = Enum.Font.Code,
        TextColor3 = Color3.fromRGB(200, 200, 200),
        TextSize = 16,
        Parent = header
    })
    closeButton.MouseButton1Click:Connect(function()
        GUI.ScreenGui:Destroy()
    end)
    
    GUI.ScoreLabel = CreateInstance("TextLabel", {
        Name = "ScoreLabel",
        Size = UDim2.new(1, -40, 0, 50),
        Position = UDim2.fromOffset(20, 55),
        BackgroundTransparency = 1,
        Font = Enum.Font.Code,
        TextColor3 = Color3.fromRGB(74, 222, 128),
        TextSize = 50,
        Text = "0%",
        TextXAlignment = Enum.TextXAlignment.Left,
        Parent = GUI.MainFrame
    })
    
    GUI.StatusLabel = CreateInstance("TextLabel", {
        Name = "StatusLabel",
        Size = UDim2.new(1, -40, 0, 20),
        Position = UDim2.fromOffset(20, 105),
        BackgroundTransparency = 1,
        Font = Enum.Font.Code,
        TextColor3 = Color3.fromRGB(180, 180, 180),
        TextSize = 14,
        Text = "Initializing...",
        TextXAlignment = Enum.TextXAlignment.Left,
        Parent = GUI.MainFrame
    })
    
    local consoleBtn = CreateInstance("TextButton", {
        Name = "ViewConsoleButton",
        Size = UDim2.new(1, -40, 0, 35),
        Position = UDim2.fromAnchorPoint(0.5, 1, 0, -20),
        AnchorPoint = Vector2.new(0.5, 1),
        BackgroundColor3 = Color3.fromRGB(40, 40, 40),
        Font = Enum.Font.Code,
        Text = "View Details in Console",
        TextColor3 = Color3.fromRGB(220, 220, 220),
        TextSize = 14,
        Parent = GUI.MainFrame
    })
    CreateInstance("UICorner", { CornerRadius = new(UDim, 0, 6), Parent = consoleBtn })
    CreateInstance("UIStroke", { Color = Color3.fromRGB(80, 80, 80), Thickness = 1, Parent = consoleBtn })

    consoleBtn.MouseButton1Click:Connect(function()
        GUI:ViewInConsole()
    end)
    
    Log("Info", "GUI Created successfully.")
end

function GUI:UpdateStatus(text)
    if not GUI.StatusLabel then return end
    pcall(function()
        GUI.StatusLabel.Text = tostring(text)
    end)
end

function GUI:UpdateScore(passed, total)
    if not GUI.ScoreLabel then return end
    pcall(function()
        local percent = 0
        if total > 0 then
            percent = math.floor((passed / total) * 100)
        end
        GUI.ScoreLabel.Text = tostring(percent) .. "%"
        
        if percent >= 80 then
            GUI.ScoreLabel.TextColor3 = Color3.fromRGB(74, 222, 128)
        elseif percent >= 50 then
            GUI.ScoreLabel.TextColor3 = Color3.fromRGB(250, 204, 21)
        else
            GUI.ScoreLabel.TextColor3 = Color3.fromRGB(248, 113, 113)
        end
    end)
end

function GUI:ShowFinalLink(url)
    if not GUI.MainFrame then return end
    
    pcall(function()
        local linkBox = CreateInstance("TextBox", {
            Name = "LinkBox",
            Size = UDim2.new(1, -130, 0, 40),
            Position = UDim2.fromOffset(20, 135),
            BackgroundColor3 = Color3.fromRGB(10, 10, 10),
            ClearTextOnFocus = false,
            Text = url,
            Font = Enum.Font.Code,
            TextColor3 = Color3.fromRGB(167, 243, 208),
            TextSize = 14,
            TextXAlignment = Enum.TextXAlignment.Left,
            Parent = GUI.MainFrame
        })
        CreateInstance("UICorner", { CornerRadius = new(UDim, 0, 6), Parent = linkBox })
        CreateInstance("UIStroke", { Color = Color3.fromRGB(80, 80, 80), Thickness = 1, Parent = linkBox })

        local copyBtn = CreateInstance("TextButton", {
            Name = "CopyButton",
            Size = UDim2.fromOffset(90, 40),
            Position = UDim2.new(1, -20, 0, 135),
            AnchorPoint = Vector2.new(1, 0),
            BackgroundColor3 = Color3.fromRGB(60, 60, 60),
            Font = Enum.Font.Code,
            Text = "Copy",
            TextColor3 = Color3.fromRGB(220, 220, 220),
            TextSize = 14,
            Parent = GUI.MainFrame
        })
        CreateInstance("UICorner", { CornerRadius = new(UDim, 0, 6), Parent = copyBtn })
        CreateInstance("UIStroke", { Color = Color3.fromRGB(80, 80, 80), Thickness = 1, Parent = copyBtn })
        
        copyBtn.MouseButton1Click:Connect(function()
            if setclipboard then
                pcall(setclipboard, url)
                copyBtn.Text = "Copied!"
                wait(2)
                copyBtn.Text = "Copy"
            else
                GUI:UpdateStatus("setclipboard not found. Copy manually.")
            end
        end)
    end)
end

function GUI:ViewInConsole()
    Log("Info", "================ WBT TEST LOGS ================")
    Log("Info", ("Executor: %s (Version: %s)"):format(WBT.Info.Executor, WBT.Info.Version))
    Log("Info", ("Final Score: %d/%d (%d%%)"):format(WBT.Stats.Passed, WBT.Stats.Total, (WBT.Stats.Total > 0 and math.floor((WBT.Stats.Passed / WBT.Stats.Total) * 100) or 0)))
    Log("Info", "===============================================")
    
    for category, funcs in pairs(WBT.Results) do
        print(":: " .. category .. " ::")
        for funcName, status in pairs(funcs) do
            local statusText = ("[%s]"):format(status:upper())
            print(string.format("  %-20s %s", funcName, statusText))
        end
    end
    
    Log("Info", "================ END OF LOGS ================")
    GUI:UpdateStatus("Logs printed to console.")
end


WBT.Test = {}

function WBT.Test:Run(category, name, testFunc)
    if not WBT.Results[category] then
        WBT.Results[category] = {}
    end
    
    WBT.Stats.Total = WBT.Stats.Total + 1
    local status, result = pcall(testFunc)
    local testStatus
    
    if not status then
        Log("Warn", ("Test for '%s' failed to run: %s"):format(name, tostring(result)))
        testStatus = "fail"
    elseif result == "unsupported" then
        Log("Info", ("Function '%s' is not supported."):format(name))
        testStatus = "unsupported"
    elseif result == true then
        Log("Info", ("Test for '%s' PASSED."):format(name))
        testStatus = "pass"
        WBT.Stats.Passed = WBT.Stats.Passed + 1
    else
        Log("Warn", ("Test for '%s' FAILED. (Result: %s)"):format(name, tostring(result)))
        testStatus = "fail"
    end
    
    WBT.Results[category][name] = testStatus
    pcall(GUI.UpdateScore, GUI, WBT.Stats.Passed, WBT.Stats.Total)
end

function WBT:GetExecutorInfo()
    local s, name = pcall(identifyexecutor)
    if s and type(name) == "string" then
        WBT.Info.Executor = name
        local s_ver, ver = pcall(getexecutorversion)
        if s_ver and ver then
            WBT.Info.Version = tostring(ver)
        end
        return
    end
    
    s, name = pcall(getexecutorname)
    if s and type(name) == "string" then
        WBT.Info.Executor = name
        return
    end

    if _G._VERSION then
        WBT.Info.Executor = _G._VERSION
    end
end

function WBT:RunAllTests()
    Log("Info", "Starting World Benchmark Test...")
    pcall(GUI.UpdateStatus, GUI, "Running tests...")
    
    WBT:GetExecutorInfo()
    pcall(GUI.UpdateStatus, GUI, ("Executor: %s"):format(WBT.Info.Executor))
    wait(0.5)
    
    local T = WBT.Test
    
    local category = "Core Environment & Globals"
    pcall(GUI.UpdateStatus, GUI, "Testing: " .. category)
    T:Run(category, "getgenv", function()
        if not getgenv then return "unsupported" end
        local s, genv = pcall(getgenv)
        return s and type(genv) == "table" and genv._G == _G
    end)
    T:Run(category, "getrenv", function()
        if not getrenv then return "unsupported" end
        local s, renv = pcall(getrenv)
        return s and type(renv) == "table" and renv.game == game
    end)
    T:Run(category, "getreg", function()
        if not getreg then return "unsupported" end
        local s, reg = pcall(getreg)
        return s and type(reg) == "table"
    end)
    T:Run(category, "getgc", function()
        if not getgc then return "unsupported" end
        local s, gc = pcall(getgc)
        return s and type(gc) == "table"
    end)
    T:Run(category, "getinstances", function()
        if not getinstances then return "unsupported" end
        local s, inst = pcall(getinstances)
        return s and type(inst) == "table" and #inst > 0
    end)
    T:Run(category, "getnilinstances", function()
        if not getnilinstances then return "unsupported" end
        local s, inst = pcall(getnilinstances)
        return s and type(inst) == "table"
    end)
    T:Run(category, "getscripts", function()
        if not getscripts then return "unsupported" end
        local s, scripts = pcall(getscripts)
        return s and type(scripts) == "table" and #scripts > 0
    end)
    T:Run(category, "getloadedmodules", function()
        if not getloadedmodules then return "unsupported" end
        local s, mods = pcall(getloadedmodules)
        return s and type(mods) == "table"
    end)
    T:Run(category, "getconnections", function()
        if not getconnections then return "unsupported" end
        local s, conns = pcall(getconnections, game:GetService("RunService").Heartbeat)
        return s and type(conns) == "table"
    end)
    T:Run(category, "getthreadidentity", function()
        if not getthreadidentity then return "unsupported" end
        local s, ident = pcall(getthreadidentity)
        return s and type(ident) == "number"
    end)
    T:Run(category, "setthreadidentity", function()
        if not setthreadidentity then return "unsupported" end
        local s = pcall(setthreadidentity, 7)
        pcall(setthreadidentity, 2)
        return s
    end)
    T:Run(category, "firesignal", function() return not not firesignal end)
    T:Run(category, "fireclickdetector", function() return not not fireclickdetector end)
    T:Run(category, "firetouchinterest", function() return not not firetouchinterest end)
    T:Run(category, "is_executor_closure", function() return not not is_executor_closure end)
    T:Run(category, "is_syn_closure", function() return not not is_syn_closure end)
    T:Run(category, "checkcaller", function()
        if not checkcaller then return "unsupported" end
        local s, is_exec = pcall(checkcaller)
        return s and type(is_exec) == "boolean"
    end)
    wait(0.05)

    category = "Filesystem (I/O)"
    pcall(GUI.UpdateStatus, GUI, "Testing: " .. category)
    T:Run(category, "writefile", function() return not not writefile end)
    T:Run(category, "readfile", function() return not not readfile end)
    T:Run(category, "appendfile", function() return not not appendfile end)
    T:Run(category, "loadfile", function() return not not loadfile end)
    T:Run(category, "listfiles", function() return not not listfiles end)
    T:Run(category, "isfile", function() return not not isfile end)
    T:Run(category, "isfolder", function() return not not isfolder end)
    T:Run(category, "makefolder", function() return not not makefolder end)
    T:Run(category, "delfile", function() return not not delfile end)
    T:Run(category, "delfolder", function() return not not delfolder end)
    T:Run(category, "FS I/O Test", function()
        if not writefile or not readfile or not isfile or not delfile then return "unsupported" end
        local test_path = "wbt_test_file.txt"
        local test_content = "WBT_FS_TEST_" .. math.random(1e5, 1e6)
        local s_write = pcall(writefile, test_path, test_content)
        if not s_write then return "writefail" end
        local s_read, content = pcall(readfile, test_path)
        if not s_read then 
            pcall(delfile, test_path)
            return "readfail"
        end
        local s_del = pcall(delfile, test_path)
        if not s_del then return "delfail" end
        return content == test_content
    end)
    wait(0.05)

    category = "Metatable & Debugging"
    pcall(GUI.UpdateStatus, GUI, "Testing: " .. category)
    T:Run(category, "getrawmetatable", function()
        if not getrawmetatable then return "unsupported" end
        local s, mt = pcall(getrawmetatable, game)
        return s and type(mt) == "table"
    end)
    T:Run(category, "setrawmetatable", function()
        if not setrawmetatable then return "unsupported" end
        local t = {}
        local mt = {}
        local s = pcall(setrawmetatable, t, mt)
        return s and getrawmetatable(t) == mt
    end)
    T:Run(category, "getmetatable", function()
        if not getmetatable then return "unsupported" end
        local t = {}
        local mt = {}
        setmetatable(t, mt)
        return getmetatable(t) == mt
    end)
    T:Run(category, "setmetatable", function()
        if not setmetatable then return "unsupported" end
        local t = {}
        local mt = {}
        pcall(setmetatable, t, mt)
        return getmetatable(t) == mt
    end)
    T:Run(category, "setreadonly", function() return not not setreadonly end)
    T:Run(category, "isreadonly", function() return not not isreadonly end)
    T:Run(category, "hookmetamethod", function() return not not hookmetamethod end)
    T:Run(category, "getnamecallmethod", function() return not not getnamecallmethod end)
    T:Run(category, "setnamecallmethod", function() return not not setnamecallmethod end)
    T:Run(category, "hookfunction", function()
        if not hookfunction then return "unsupported" end
        local old_print = print
        local success = false
        local s, err = pcall(hookfunction, print, function() success = true end)
        
        if not s then 
            Log("Warn", "hookfunction pcall failed: " .. tostring(err))
            pcall(hookfunction, print, old_print)
            return false 
        end
        
        pcall(print, "")
        pcall(hookfunction, print, old_print)
        return success
    end)
    T:Run(category, "clonefunction", function() return not not clonefunction end)
    T:Run(category, "newcclosure", function() return not not newcclosure end)
    T:Run(category, "debug.getconstants", function() return debug and not not debug.getconstants end)
    T:Run(category, "debug.getupvalues", function() return debug and not not debug.getupvalues end)
    T:Run(category, "debug.setupvalue", function() return debug and not not debug.setupvalue end)
    T:Run(category, "debug.getproto", function() return debug and not not debug.getproto end)
    T:Run(category,KA, "debug.setstack", function() return debug and not not debug.setstack end)
    T:Run(category, "debug.getmetatable", function() return debug and not not debug.getmetatable end)
    T:Run(category, "debug.setmetatable", function() return debug and not not debug.setmetatable end)
    T:Run(category, "debug.getfenv", function() return debug and not not debug.getfenv end)
    T:Run(category, "debug.setfenv", function() return debug and not not debug.setfenv end)
    wait(0.05)

    category = "Console"
    pcall(GUI.UpdateStatus, GUI, "Testing: " .. category)
    T:Run(category, "rconsoleprint", function() return not not rconsoleprint end)
    T:Run(category, "rconsoleinfo", function() return not not rconsoleinfo end)
    T:Run(category, "rconsolewarn", function() return not not rconsolewarn end)
    T:Run(category, "rconsoleerr", function() return not not rconsoleerr end)
    T:Run(category, "rconsoleclear", function() return not not rconsoleclear end)
    T:Run(category, "rconsolename", function() return not not rconsolename end)
    T:Run(category, "rconsoleinput", function() return not not rconsoleinput end)
    wait(0.05)
    
    category = "Input Simulation"
    pcall(GUI.UpdateStatus, GUI, "Testing: " .. category)
    T:Run(category, "keypress", function() return not not keypress end)
    T:Run(category, "keyrelease", function() return not not keyrelease end)
    T:Run(category, "mouse1click", function() return not not mouse1click end)
    T:Run(category, "mouse1press", function() return not not mouse1press end)
    T:Run(category, "mouse1release", function() return not not mouse1release end)
    T:Run(category, "mouse2click", function() return not not mouse2click end)
    T:Run(category, "mouse2press", function() return not not mouse2press end)
    T:Run(category, "mouse2release", function() return not not mouse2release end)
    T:Run(category, "mousescroll", function() return not not mousescroll end)
    T:Run(category, "mousemoveabs", function() return not not mousemoveabs end)
    T:Run(category, "mousemoverel", function() return not not mousemoverel end)
    wait(0.05)
    
    category = "Cryptography & Encoding"
    pcall(GUI.UpdateStatus, GUI, "Testing: " .. category)
    T:Run(category, "crypt.encrypt", function() return crypt and not not crypt.encrypt end)
    T:Run(category, "crypt.decrypt", function() return crypt and not not crypt.decrypt end)
    T:Run(category, "crypt.hash (md5)", function()
        if not crypt or not crypt.hash then return "unsupported" end
        local s, h = pcall(crypt.hash, "md5", "test")
        return s and h == "098f6bcd4621d373cade4e832627b4f6"
    end)
    T:Run(category, "crypt.hash (sha256)", function()
        if not crypt or not crypt.hash then return "unsupported" end
        local s, h = pcall(crypt.hash, "sha256", "test")
        return s and h == "9f86d081884c7d659a2feaa0c55ad015a3bf4f1b2b0b822cd15d6c15b0f00a08"
    end)
    T:Run(category, "base64.encode", function() return base64 and not not base64.encode end)
    T:Run(category, "base64.decode", function() return base64 and not not base64.decode end)
    T:Run(category, "lz4.compress", function() return lz4 and not not lz4.compress end)
    T:Run(category, "lz4.decompress", function() return lz4 and not not lz4.decompress end)
    wait(0.05)
    
    category = "Drawing Library"
    pcall(GUI.UpdateStatus, GUI, "Testing: " .. category)
    local function testDrawing(type)
        if not Drawing or not Drawing.new then return "unsupported" end
        local s, obj = pcall(Drawing.new, type)
        if not s or not obj then return false end
        pcall(obj.Remove, obj)
        return true
    end
    T:Run(category, "Drawing.new(Line)", function() return testDrawing("Line") end)
    T:Run(category, "Drawing.new(Text)", function() return testDrawing("Text") end)
    T:Run(category, "Drawing.new(Image)", function() return testDrawing("Image") end)
    T:Run(category, "Drawing.new(Circle)", function() return testDrawing("Circle") end)
    T:Run(category, "Drawing.new(Square)", function() return testDrawing("Square") end)
    T:Run(category, "Drawing.new(Quad)", function() return testDrawing("Quad") end)
    T:Run(category, "Drawing.new(Triangle)", function() return testDrawing("Triangle") end)
    wait(0.05)

    category = "SUNC Extensions"
    pcall(GUI.UpdateStatus, GUI, "Testing: " .. category)
    T:Run(category, "getscriptbytecode", function() return not not getscriptbytecode end)
    T:Run(category, "getscripthash", function() return not not getscripthash end)
    T:Run(category, "gethui", function()
        if not gethui then return "unsupported" end
        local s, hui = pcall(gethui)
        return s and hui:IsA("ScreenGui")
    end)
    T:Run(category, "cloneref", function() return not not cloneref end)
    T:Run(category, "queue_on_teleport", function() return not not queue_on_teleport end)
    T:Run(category, "setclipboard", function() return not not setclipboard end)
    T:Run(category, "getcustomasset", function() return not not getcustomasset end)
    T:Run(category, "secure_call", function() return not not secure_call end)
    T:Run(category, "getinstancein", function() return not not getinstancein end)
    T:Run(category, "getinstancesin", function() return not not getinstancesin end)
    
    category = "Executor Info"
    pcall(GUI.UpdateStatus, GUI, "Testing: " .. category)
    T:Run(category, "identifyexecutor", function()
        local s, name = pcall(identifyexecutor)
        return s and type(name) == "string"
    end)
    T:Run(category, "getexecutorname", function()
        local s, name = pcall(getexecutorname)
        return s and type(name) == "string"
    end)

    category = "bit Library"
    pcall(GUI.UpdateStatus, GUI, "Testing: " .. category)
    local bit_lib = bit or bit32
    T:Run(category, "bit.band", function() return bit_lib and not not bit_lib.band end)
    T:Run(category, "bit.bor", function() return bit_lib and not not bit_lib.bor end)
    T:Run(category, "bit.bxor", function() return bit_lib and not not bit_lib.bxor end)
    T:Run(category, "bit.lshift", function() return bit_lib and not not bit_lib.lshift end)
    T:Run(category, "bit.rshift", function() return bit_lib and not not bit_lib.rshift end)
    T:Run(category, "bit.arshift", function() return bit_lib and not not bit_lib.arshift end)
    T:Run(category, "bit.not", function() return bit_lib and not not bit_lib["not"] end)
    
    category = "http Library"
    pcall(GUI.UpdateStatus, GUI, "Testing: " .. category)
    T:Run(category, "http_request", function() return not not http_request end)
    T:Run(category, "request", function() return not not request end)
    T:Run(category, "http.get", function() return http and not not http.get end)
    T:Run(category, "http.post", function() return http and not not http.post end)

    Log("Info", "All tests completed.")
    pcall(GUI.UpdateStatus, GUI, "All tests completed.")
end

local b64_char = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
function WBT:Base64Encode(data)
    if _G.base64 and _G.base64.encode then
        local s, res = pcall(_G.base64.encode, data)
        if s then return res end
    end
    
    Log("Warn", "Using fallback Base64 encoder.")
    return ((data:gsub('.', function(x) 
        local r, b = '', x:byte()
        for i = 8, 1, -1 do r = r .. (b % 2^i - b % 2^(i-1) > 0 and '1' or '0') end
        return r;
    end) .. '0000'):gsub('%d%d%d?%d?%d?%d?', function(x)
        if (#x < 6) then return '' end
        local c = 0
        for i = 1, 6 do c = c + (x:sub(i, i) == '1' and 2^(6-i) or 0) end
        return b64_char:sub(c+1, c+1)
    end) .. ({'','==','='})[#data % 3 + 1])
end

function WBT:SerializeJSON(tbl)
    local function escape_str(s)
        local replacements = {
            ["\\"] = "\\\\", ["\""] = "\\\"", ["\b"] = "\\b",
            ["\f"] = "\\f", ["\n"] = "\\n", ["\r"] = "\\r", ["\t"] = "\\t"
        }
        return '"' .. s:gsub("[\"\b\f\n\r\t\\]", replacements) .. '"'
    end
    
    local seen = {}
    local function serialize(o)
        local o_type = type(o)
        
        if o_type == "table" then
            if seen[o] then
                return '"[CircularReference]"'
            end
            seen[o] = true
            
            local parts = {}
            local is_array = true
            local i = 1
            for k, _ in pairs(o) do
                if type(k) ~= "number" or k ~= i then
                    is_array = false
                end
                i = i + 1
            end
            
            if is_array then
                for j = 1, #o do
                    table.insert(parts, serialize(o[j]))
                end
                seen[o] = nil
                return '[' .. table.concat(parts, ",") .. ']'
            else
                for k, v in pairs(o) do
                    table.insert(parts, escape_str(tostring(k)) .. ":" .. serialize(v))
                end
                seen[o] = nil
                return '{' .. table.concat(parts, ",") .. '}'
            end
            
        elseif o_type == "string" then
            return escape_str(o)
        elseif o_type == "number" or o_type == "boolean" then
            return tostring(o)
        elseif o_type == "nil" then
            return "null"
        else
            return '"' .. tostring(o) .. '"'
        end
    end
    
    return serialize(tbl)
end

function WBT:Main()
    print("[WBT] Main function started.")
    
    if WBT_SETTINGS.UseGui then
        print("[WBT] Attempting to create GUI...")
        local s, e = pcall(GUI.Create, GUI)
        if not s then
            print("[WBT] GUI:Create() FAILED:", e)
        else
            print("[WBT] GUI creation complete.")
        end
    end
    
    print("[WBT] Attempting to run all tests...")
    WBT:RunAllTests()
    print("[WBT] All tests completed. Generating link...")
    
    pcall(GUI.UpdateStatus, GUI, "Generating result link...")
    
    local payload = {
        info = WBT.Info,
        results = WBT.Results
    }
    
    local json_data
    local s, res = pcall(game:GetService("HttpService").JSONEncode, game:GetService("HttpService"), payload)
    if s and res then
        json_data = res
        Log("Info", "Using HttpService for JSON encoding.")
    else
        Log("Warn", "HttpService JSONEncode failed. Using fallback serializer.", tostring(res))
        json_data = WBT:SerializeJSON(payload)
    end
    
    local base64_data = WBT:Base64Encode(json_data)
    local scan_id = math.floor(tick() * 1000 % 1000000000) + 1000000000
    local url = ("%s/#scan-%s-%s"):format(WBT_SETTINGS.WebsiteBaseUrl, scan_id, base64_data)
    
    Log("Info", "Test Complete!")
    Log("Info", "Your unique results URL is:")
    Log("Info", url)
    
    if WBT_SETTINGS.AutoCopyLink then
        if setclipboard then
            pcall(setclipboard, url)
            Log("Info", "Result link copied to clipboard.")
            pcall(GUI.UpdateStatus, GUI, "Test Complete! Result link copied.")
        else
            Log("Warn", "setclipboard is not available. Please copy the link manually.")
            pcall(GUI.UpdateStatus, GUI, "Test Complete! Copy link below.")
        end
    end
    
    pcall(GUI.ShowFinalLink, GUI, url)
    print("[WBT] Main function finished.")
end

print("[WBT] Spawning Main thread...")
spawn(function()
    local s, e = pcall(WBT.Main, WBT)
    if not s then
        print("[WBT] MAIN SCRIPT ERROR:", e)
    end
end)
