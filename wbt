print("WBT Script Initialized")

local WBT_SETTINGS = {
    WebsiteBaseUrl = "https://worldbt.netlify.app",
    LogLevel = "Info",
    UseGui = true,
    AutoCopyLink = true,
}

local WBT = {}
WBT.Info = { Executor = "Unknown", Version = "N/A" }
WBT.Results = {}
WBT.Logs = {}
WBT.Stats = { Total = 0, Passed = 0 }

local function Log(level, ...)
    local message = table.concat({...}, " ")
    table.insert(WBT.Logs, {Level = level, Message = message, Time = os.time()})
    
    local levels = {Debug = 0, Info = 1, Warn = 2, Error = 3}
    if (levels[level] or 1) < (levels[WBT_SETTINGS.LogLevel] or 1) then
        return
    end

    local prefix = "[WBT " .. level:upper() .. "]"
    
    if rconsoleprint then
        local printFunc = ({
            Info = rconsoleinfo,
            Warn = rconsolewarn,
            Error = rconsoleerr,
            Debug = rconsoleprint
        })[level] or rconsoleprint
        
        printFunc(prefix, message)
    else
        if level == "Error" then
            warn(prefix, message)
        elseif level == "Warn" then
            warn(prefix, message)
        else
            print(prefix, message)
        end
    end
end

local GUI = {}
GUI.ScreenGui = nil
GUI.MainFrame = nil
GUI.StatusLabel = nil
GUI.ScoreLabel = nil

function GUI:Create()
    if not WBT_SETTINGS.UseGui then return end
    
    pcall(function()
        if GUI.ScreenGui then
            GUI.ScreenGui:Destroy()
        end
        
        local parent = gethui and gethui() or game:GetService("CoreGui")
        
        GUI.ScreenGui = Instance.new("ScreenGui")
        GUI.ScreenGui.Name = "WBT_Gui_" .. math.random(1e5, 1e6)
        GUI.ScreenGui.ResetOnSpawn = false
        GUI.ScreenGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
        
        GUI.MainFrame = Instance.new("Frame")
        GUI.MainFrame.Name = "MainFrame"
        GUI.MainFrame.Size = UDim2.fromOffset(400, 250)
        GUI.MainFrame.Position = UDim2.fromScale(0.5, 0.5)
        GUI.MainFrame.AnchorPoint = Vector2.new(0.5, 0.5)
        GUI.MainFrame.BackgroundColor3 = Color3.fromRGB(20, 20, 20)
        GUI.MainFrame.BackgroundTransparency = 0.2
        GUI.MainFrame.BorderSizePixel = 0
        
        local corner = Instance.new("UICorner")
        corner.CornerRadius = UDim.new(0, 8)
        corner.Parent = GUI.MainFrame
        
        local gradient = Instance.new("UIGradient")
        gradient.Color = ColorSequence.new({
            ColorSequenceKeypoint.new(0, Color3.fromRGB(30, 30, 30)),
            ColorSequenceKeypoint.new(1, Color3.fromRGB(10, 10, 10))
        })
        gradient.Rotation = 90
        gradient.Transparency = NumberSequence.new(0.3)
        gradient.Parent = GUI.MainFrame
        
        local stroke = Instance.new("UIStroke")
        stroke.Color = Color3.fromRGB(100, 100, 100)
        stroke.Transparency = 0.5
        stroke.Thickness = 1
        stroke.Parent = GUI.MainFrame

        local header = Instance.new("Frame")
        header.Name = "Header"
        header.Size = UDim2.new(1, 0, 0, 40)
        header.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
        header.BackgroundTransparency = 0.3
        header.Parent = GUI.MainFrame
        
        local headerCorner = Instance.new("UICorner")
        headerCorner.CornerRadius = UDim.new(0, 8)
        headerCorner.Parent = header
        
        local title = Instance.new("TextLabel")
        title.Name = "Title"
        title.Size = UDim2.new(1, -10, 1, 0)
        title.Position = UDim2.fromOffset(10, 0)
        title.BackgroundTransparency = 1
        title.Text = "WBT - World Benchmark Test"
        title.Font = Enum.Font.Code
        title.TextColor3 = Color3.fromRGB(255, 255, 255)
        title.TextSize = 18
        title.TextXAlignment = Enum.TextXAlignment.Left
        title.Parent = header
        
        local closeButton = Instance.new("TextButton")
        closeButton.Name = "CloseButton"
        closeButton.Size = UDim2.fromOffset(20, 20)
        closeButton.Position = UDim2.new(1, -25, 0.5, 0)
        closeButton.AnchorPoint = Vector2.new(0.5, 0.5)
        closeButton.BackgroundTransparency = 1
        closeButton.Text = "X"
        closeButton.Font = Enum.Font.Code
        closeButton.TextColor3 = Color3.fromRGB(220, 220, 220)
        closeButton.TextSize = 16
        closeButton.Parent = header
        closeButton.MouseButton1Click:Connect(function()
            GUI.ScreenGui:Destroy()
        end)
        
        GUI.ScoreLabel = Instance.new("TextLabel")
        GUI.ScoreLabel.Name = "ScoreLabel"
        GUI.ScoreLabel.Size = UDim2.new(1, -20, 0, 40)
        GUI.ScoreLabel.Position = UDim2.fromOffset(10, 50)
        GUI.ScoreLabel.BackgroundTransparency = 1
        GUI.ScoreLabel.Font = Enum.Font.Code
        GUI.ScoreLabel.TextColor3 = Color3.fromRGB(74, 222, 128)
        GUI.ScoreLabel.TextSize = 32
        GUI.ScoreLabel.Text = "0%"
        GUI.ScoreLabel.TextXAlignment = Enum.TextXAlignment.Left
        GUI.ScoreLabel.Parent = GUI.MainFrame
        
        GUI.StatusLabel = Instance.new("TextLabel")
        GUI.StatusLabel.Name = "StatusLabel"
        GUI.StatusLabel.Size = UDim2.new(1, -20, 0, 20)
        GUI.StatusLabel.Position = UDim2.fromOffset(10, 85)
        GUI.StatusLabel.BackgroundTransparency = 1
        GUI.StatusLabel.Font = Enum.Font.Code
        GUI.StatusLabel.TextColor3 = Color3.fromRGB(200, 200, 200)
        GUI.StatusLabel.TextSize = 14
        GUI.StatusLabel.Text = "Initializing..."
        GUI.StatusLabel.TextXAlignment = Enum.TextXAlignment.Left
        GUI.StatusLabel.Parent = GUI.MainFrame
        
        local consoleBtn = Instance.new("TextButton")
        consoleBtn.Name = "ViewConsoleButton"
        consoleBtn.Size = UDim2.new(1, -20, 0, 30)
        consoleBtn.Position = UDim2.fromAnchorPoint(0.5, 1, 0, -15)
        consoleBtn.AnchorPoint = Vector2.new(0.5, 1)
        consoleBtn.BackgroundColor3 = Color3.fromRGB(40, 40, 40)
        consoleBtn.Font = Enum.Font.Code
        consoleBtn.Text = "View Details in Console"
        consoleBtn.TextColor3 = Color3.fromRGB(220, 220, 220)
        consoleBtn.TextSize = 14
        consoleBtn.Parent = GUI.MainFrame
        consoleBtn.MouseButton1Click:Connect(function()
            GUI:ViewInConsole()
        end)
        
        local btnCorner = Instance.new("UICorner")
        btnCorner.CornerRadius = UDim.new(0, 4)
        btnCorner.Parent = consoleBtn
        
        GUI.MainFrame.Parent = GUI.ScreenGui
        GUI.ScreenGui.Parent = parent
        
        Log("Info", "GUI Created successfully.")

        local UserInputService = game:GetService("UserInputService")
        local dragging = false
        local dragInput = nil
        local dragStart = nil
        local startPos = nil
        
        header.InputBegan:Connect(function(input)
            if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
                dragging = true
                dragStart = input.Position
                startPos = GUI.MainFrame.Position
                input.Changed:Connect(function()
                    if input.UserInputState == Enum.UserInputState.End then
                        dragging = false
                    end
                end)
            end
        end)

        header.InputChanged:Connect(function(input)
            if input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch then
                if dragging then
                    local delta = input.Position - dragStart
                    GUI.MainFrame.Position = UDim2.new(startPos.X.Scale, startPos.X.Offset + delta.X, startPos.Y.Scale, startPos.Y.Offset + delta.Y)
                end
            end
        end)
    end)
end

function GUI:UpdateStatus(text)
    if not GUI.StatusLabel then return end
    pcall(function()
        GUI.StatusLabel.Text = tostring(text)
    end)
end

function GUI:UpdateScore(passed, total)
    if not GUI.ScoreLabel then return end
    pcall(function()
        local percent = 0
        if total > 0 then
            percent = math.floor((passed / total) * 100)
        end
        GUI.ScoreLabel.Text = tostring(percent) .. "%"
        
        if percent >= 80 then
            GUI.ScoreLabel.TextColor3 = Color3.fromRGB(74, 222, 128)
        elseif percent >= 50 then
            GUI.ScoreLabel.TextColor3 = Color3.fromRGB(250, 204, 21)
        else
            GUI.ScoreLabel.TextColor3 = Color3.fromRGB(248, 113, 113)
        end
    end)
end

function GUI:ShowFinalLink(url)
    if not GUI.MainFrame then return end
    
    GUI:UpdateStatus("Test Complete! Result link copied.")
    
    pcall(function()
        local linkBox = Instance.new("TextBox")
        linkBox.Name = "LinkBox"
        linkBox.Size = UDim2.new(1, -110, 0, 40)
        linkBox.Position = UDim2.fromOffset(10, 120)
        linkBox.BackgroundColor3 = Color3.fromRGB(40, 40, 40)
        linkBox.ClearTextOnFocus = false
        linkBox.Text = url
        linkBox.Font = Enum.Font.Code
        linkBox.TextColor3 = Color3.fromRGB(167, 243, 208)
        linkBox.TextSize = 12
        linkBox.TextXAlignment = Enum.TextXAlignment.Left
        linkBox.Parent = GUI.MainFrame
        
        local corner = Instance.new("UICorner")
        corner.CornerRadius = UDim.new(0, 4)
        corner.Parent = linkBox
        
        local copyBtn = Instance.new("TextButton")
        copyBtn.Name = "CopyButton"
        copyBtn.Size = UDim2.fromOffset(80, 40)
        copyBtn.Position = UDim2.new(1, -10, 0, 120)
        copyBtn.AnchorPoint = Vector2.new(1, 0)
        copyBtn.BackgroundColor3 = Color3.fromRGB(60, 60, 60)
        copyBtn.Font = Enum.Font.Code
        copyBtn.Text = "Copy"
        copyBtn.TextColor3 = Color3.fromRGB(220, 220, 220)
        copyBtn.TextSize = 14
        copyBtn.Parent = GUI.MainFrame
        
        local corner2 = Instance.new("UICorner")
        corner2.CornerRadius = UDim.new(0, 4)
        corner2.Parent = copyBtn
        
        copyBtn.MouseButton1Click:Connect(function()
            if setclipboard then
                pcall(setclipboard, url)
                copyBtn.Text = "Copied!"
                wait(2)
                copyBtn.Text = "Copy"
            else
                GUI:UpdateStatus("setclipboard not found. Copy manually.")
            end
        end)
    end)
end

function GUI:ViewInConsole()
    Log("Info", "================ WBT TEST LOGS ================")
    Log("Info", ("Executor: %s (Version: %s)"):format(WBT.Info.Executor, WBT.Info.Version))
    Log("Info", ("Final Score: %d/%d (%d%%)"):format(WBT.Stats.Passed, WBT.Stats.Total, (WBT.Stats.Total > 0 and math.floor((WBT.Stats.Passed / WBT.Stats.Total) * 100) or 0)))
    Log("Info", "===============================================")
    
    for category, funcs in pairs(WBT.Results) do
        print(":: " .. category .. " ::")
        for funcName, status in pairs(funcs) do
            local statusText = ("[%s]"):format(status:upper())
            print(string.format("  %-15s %s", statusText, funcName))
        end
    end
    
    Log("Info", "================ END OF LOGS ================")
    GUI:UpdateStatus("Logs printed to console.")
end


WBT.Test = {}

function WBT.Test:Run(category, name, testFunc)
    if not WBT.Results[category] then
        WBT.Results[category] = {}
    end
    
    WBT.Stats.Total = WBT.Stats.Total + 1
    local status, result = pcall(testFunc)
    local testStatus
    
    if not status then
        Log("Warn", ("Test for '%s' failed to run: %s"):format(name, tostring(result)))
        testStatus = "fail"
    elseif result == "unsupported" then
        Log("Info", ("Function '%s' is not supported."):format(name))
        testStatus = "unsupported"
    elseif result == true then
        Log("Info", ("Test for '%s' PASSED."):format(name))
        testStatus = "pass"
        WBT.Stats.Passed = WBT.Stats.Passed + 1
    else
        Log("Warn", ("Test for '%s' FAILED. (Result: %s)"):format(name, tostring(result)))
        testStatus = "fail"
    end
    
    WBT.Results[category][name] = testStatus
    GUI:UpdateScore(WBT.Stats.Passed, WBT.Stats.Total)
end

function WBT:GetExecutorInfo()
    local s, name = pcall(identifyexecutor)
    if s and type(name) == "string" then
        WBT.Info.Executor = name
        local s_ver, ver = pcall(getexecutorversion)
        if s_ver and ver then
            WBT.Info.Version = tostring(ver)
        end
        return
    end
    
    s, name = pcall(getexecutorname)
    if s and type(name) == "string" then
        WBT.Info.Executor = name
        return
    end

    if _G._VERSION then
        WBT.Info.Executor = _G._VERSION
    end
end

function WBT:RunAllTests()
    Log("Info", "Starting World Benchmark Test...")
    GUI:UpdateStatus("Running tests...")
    
    WBT:GetExecutorInfo()
    GUI:UpdateStatus(("Executor: %s"):format(WBT.Info.Executor))
    wait(0.5)
    
    local T = WBT.Test
    
    local category = "Core Environment & Globals"
    GUI:UpdateStatus("Testing: " .. category)
    T:Run(category, "getgenv", function()
        if not getgenv then return "unsupported" end
        local s, genv = pcall(getgenv)
        return s and type(genv) == "table" and genv._G == _G
    end)
    T:Run(category, "getrenv", function()
        if not getrenv then return "unsupported" end
        local s, renv = pcall(getrenv)
        return s and type(renv) == "table" and renv.game == game
    end)
    T:Run(category, "getreg", function()
        if not getreg then return "unsupported" end
        local s, reg = pcall(getreg)
        return s and type(reg) == "table"
    end)
    T:Run(category, "getgc", function()
        if not getgc then return "unsupported" end
        local s, gc = pcall(getgc)
        return s and type(gc) == "table"
    end)
    T:Run(category, "getinstances", function()
        if not getinstances then return "unsupported" end
        local s, inst = pcall(getinstances)
        return s and type(inst) == "table" and #inst > 0
    end)
    T:Run(category, "getnilinstances", function()
        if not getnilinstances then return "unsupported" end
        local s, inst = pcall(getnilinstances)
        return s and type(inst) == "table"
    end)
    T:Run(category, "getscripts", function()
        if not getscripts then return "unsupported" end
        local s, scripts = pcall(getscripts)
        return s and type(scripts) == "table" and #scripts > 0
    end)
    T:Run(category, "getloadedmodules", function()
        if not getloadedmodules then return "unsupported" end
        local s, mods = pcall(getloadedmodules)
        return s and type(mods) == "table"
    end)
    T:Run(category, "getconnections", function()
        if not getconnections then return "unsupported" end
        local s, conns = pcall(getconnections, game:GetService("RunService").Heartbeat)
        return s and type(conns) == "table"
    end)
    T:Run(category, "firesignal", function() return not not firesignal end)
    T:Run(category, "fireclickdetector", function() return not not fireclickdetector end)
    T:Run(category, "firetouchinterest", function() return not not firetouchinterest end)
    T:Run(category, "is_executor_closure", function() return not not is_executor_closure end)
    T:Run(category, "checkcaller", function()
        if not checkcaller then return "unsupported" end
        local s, is_exec = pcall(checkcaller)
        return s and type(is_exec) == "boolean"
    end)
    wait(0.01)

    category = "Filesystem (I/O)"
    GUI:UpdateStatus("Testing: " .. category)
    T:Run(category, "readfile", function() return not not readfile end)
    T:Run(category, "writefile", function() return not not writefile end)
    T:Run(category, "appendfile", function() return not not appendfile end)
    T:Run(category, "loadfile", function() return not not loadfile end)
    T:Run(category, "listfiles", function() return not not listfiles end)
    T:Run(category, "isfile", function() return not not isfile end)
    T:Run(category, "isfolder", function() return not not isfolder end)
    T:Run(category, "makefolder", function() return not not makefolder end)
    T:Run(category, "delfile", function() return not not delfile end)
    T:Run(category, "delfolder", function() return not not delfolder end)
    wait(0.01)

    category = "Metatable & Debugging"
    GUI:UpdateStatus("Testing: " .. category)
    T:Run(category, "getrawmetatable", function()
        if not getrawmetatable then return "unsupported" end
        local s, mt = pcall(getrawmetatable, game)
        return s and type(mt) == "table"
    end)
    T:Run(category, "setrawmetatable", function()
        if not setrawmetatable then return "unsupported" end
        local t = {}
        local mt = {}
        local s = pcall(setrawmetatable, t, mt)
        return s and getrawmetatable(t) == mt
    end)
    T:Run(category, "setreadonly", function() return not not setreadonly end)
    T:Run(category, "isreadonly", function() return not not isreadonly end)
    T:Run(category, "hookmetamethod", function() return not not hookmetamethod end)
    T:Run(category, "getnamecallmethod", function() return not not getnamecallmethod end)
    T:Run(category, "setnamecallmethod", function() return not not setnamecallmethod end)
    T:Run(category, "hookfunction", function()
        if not hookfunction then return "unsupported" end
        local old_print = print
        local success = false
        local s = pcall(hookfunction, print, function() success = true end)
        if not s then return false end
        pcall(print, "")
        hookfunction(print, old_print)
        return success
    end)
    T:Run(category, "clonefunction", function() return not not clonefunction end)
    T:Run(category, "newcclosure", function() return not not newcclosure end)
    T:Run(category, "debug.getconstants", function() return debug and not not debug.getconstants end)
    T:Run(category, "debug.getupvalues", function() return debug and not not debug.getupvalues end)
    T:Run(category, "debug.setupvalue", function() return debug and not not debug.setupvalue end)
    T:Run(category, "debug.getproto", function() return debug and not not debug.getproto end)
    T:Run(category, "debug.setstack", function() return debug and not not debug.setstack end)
    wait(0.01)

    category = "Console"
    GUI:UpdateStatus("Testing: " .. category)
    T:Run(category, "rconsoleprint", function() return not not rconsoleprint end)
    T:Run(category, "rconsoleinfo", function() return not not rconsoleinfo end)
    T:Run(category, "rconsolewarn", function() return not not rconsolewarn end)
    T:Run(category, "rconsoleerr", function() return not not rconsoleerr end)
    T:Run(category, "rconsoleclear", function() return not not rconsoleclear end)
    T:Run(category, "rconsolename", function() return not not rconsolename end)
    T:Run(category, "rconsoleinput", function() return not not rconsoleinput end)
    wait(0.01)
    
    category = "Input Simulation"
    GUI:UpdateStatus("Testing: " .. category)
    T:Run(category, "keypress", function() return not not keypress end)
    T:Run(category, "keyrelease", function() return not not keyrelease end)
    T:Run(category, "mouse1click", function() return not not mouse1click end)
    T:Run(category, "mouse1press", function() return not not mouse1press end)
    T:Run(category, "mouse1release", function() return not not mouse1release end)
    T:Run(category, "mouse2click", function() return not not mouse2click end)
    T:Run(category, "mousemoveabs", function() return not not mousemoveabs end)
    T:Run(category, "mousemoverel", function() return not not mousemoverel end)
    wait(0.01)
    
    category = "Cryptography & Encoding"
    GUI:UpdateStatus("Testing: " .. category)
    T:Run(category, "crypt.encrypt", function() return crypt and not not crypt.encrypt end)
    T:Run(category, "crypt.decrypt", function() return crypt and not not crypt.decrypt end)
    T:Run(category, "crypt.hash", function() return crypt and not not crypt.hash end)
    T:Run(category, "base64.encode", function() return base64 and not not base64.encode end)
    T:Run(category, "base64.decode", function() return base64 and not not base64.decode end)
    T:Run(category, "lz4.compress", function() return lz4 and not not lz4.compress end)
    T:Run(category, "lz4.decompress", function() return lz4 and not not lz4.decompress end)
    wait(0.01)
    
    category = "Drawing Library"
    GUI:UpdateStatus("Testing: " .. category)
    T:Run(category, "Drawing.new", function()
        if not Drawing or not Drawing.new then return "unsupported" end
        local s, obj = pcall(Drawing.new, "Line")
        if not s or not obj then return false end
        pcall(obj.Remove, obj)
        return true
    end)
    wait(0.01)

    category = "SUNC Extensions"
    GUI:UpdateStatus("Testing: " .. category)
    T:Run(category, "getscriptbytecode", function() return not not getscriptbytecode end)
    T:Run(category, "getscripthash", function() return not not getscripthash end)
    T:Run(category, "gethui", function()
        if not gethui then return "unsupported" end
        local s, hui = pcall(gethui)
        return s and hui:IsA("ScreenGui")
    end)
    T:Run(category, "cloneref", function() return not not cloneref end)
    T:Run(category, "queue_on_teleport", function() return not not queue_on_teleport end)
    T:Run(category, "setclipboard", function() return not not setclipboard end)
    T:Run(category, "getcustomasset", function() return not not getcustomasset end)
    
    category = "Executor Info"
    GUI:UpdateStatus("Testing: " .. category)
    T:Run(category, "identifyexecutor", function()
        local s, name = pcall(identifyexecutor)
        return s and type(name) == "string"
    end)
    T:Run(category, "getexecutorname", function()
        local s, name = pcall(getexecutorname)
        return s and type(name) == "string"
    end)

    Log("Info", "All tests completed.")
    GUI:UpdateStatus("All tests completed.")
end

local b64_char = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
function WBT:Base64Encode(data)
    if _G.base64 and _G.base64.encode then
        local s, res = pcall(_G.base64.encode, data)
        if s then return res end
    end
    
    Log("Warn", "Using fallback Base64 encoder.")
    return ((data:gsub('.', function(x) 
        local r, b = '', x:byte()
        for i = 8, 1, -1 do r = r .. (b % 2^i - b % 2^(i-1) > 0 and '1' or '0') end
        return r;
    end) .. '0000'):gsub('%d%d%d?%d?%d?%d?', function(x)
        if (#x < 6) then return '' end
        local c = 0
        for i = 1, 6 do c = c + (x:sub(i, i) == '1' and 2^(6-i) or 0) end
        return b64_char:sub(c+1, c+1)
    end) .. ({'','==','='})[#data % 3 + 1])
end

function WBT:SerializeJSON(tbl)
    local function escape_str(s)
        local replacements = {
            ["\\"] = "\\\\", ["\""] = "\\\"", ["\b"] = "\\b",
            ["\f"] = "\\f", ["\n"] = "\\n", ["\r"] = "\\r", ["\t"] = "\\t"
        }
        return '"' .. s:gsub("[\"\b\f\n\r\t\\]", replacements) .. '"'
    end
    
    local seen = {}
    local function serialize(o)
        local o_type = type(o)
        
        if o_type == "table" then
            if seen[o] then
                return '"[CircularReference]"'
            end
            seen[o] = true
            
            local parts = {}
            local is_array = true
            local i = 1
            for k, _ in pairs(o) do
                if type(k) ~= "number" or k ~= i then
                    is_array = false
                end
                i = i + 1
            end
            
            if is_array then
                for j = 1, #o do
                    table.insert(parts, serialize(o[j]))
                end
                seen[o] = nil
                return '[' .. table.concat(parts, ",") .. ']'
            else
                for k, v in pairs(o) do
                    table.insert(parts, escape_str(tostring(k)) .. ":" .. serialize(v))
                end
                seen[o] = nil
                return '{' .. table.concat(parts, ",") .. '}'
            end
            
        elseif o_type == "string" then
            return escape_str(o)
        elseif o_type == "number" or o_type == "boolean" then
            return tostring(o)
        elseif o_type == "nil" then
            return "null"
        else
            return '"' .. tostring(o) .. '"'
        end
    end
    
    return serialize(tbl)
end

function WBT:Main()
    if WBT_SETTINGS.UseGui then
        GUI:Create()
    end
    
    WBT:RunAllTests()
    
    GUI:UpdateStatus("Generating result link...")
    
    local payload = {
        info = WBT.Info,
        results = WBT.Results
    }
    
    local json_data
    local s, res = pcall(game:GetService("HttpService").JSONEncode, game:GetService("HttpService"), payload)
    if s and res then
        json_data = res
        Log("Info", "Using HttpService for JSON encoding.")
    else
        Log("Warn", "HttpService JSONEncode failed. Using fallback serializer.", tostring(res))
        json_data = WBT:SerializeJSON(payload)
    end
    
    local base64_data = WBT:Base64Encode(json_data)
    local scan_id = math.floor(tick() * 1000 % 1000000000) + 1000000000
    local url = ("%s/#scan-%s-%s"):format(WBT_SETTINGS.WebsiteBaseUrl, scan_id, base64_data)
    
    Log("Info", "Test Complete!")
    Log("Info", "Your unique results URL is:")
    Log("Info", url)
    
    if WBT_SETTINGS.AutoCopyLink then
        if setclipboard then
            pcall(setclipboard, url)
            Log("Info", "Result link copied to clipboard.")
            GUI:UpdateStatus("Test Complete! Result link copied.")
        else
            Log("Warn", "setclipboard is not available. Please copy the link manually.")
            GUI:UpdateStatus("Test Complete! Copy link below.")
        end
    end
    
    GUI:ShowFinalLink(url)
end

pcall(WBT.Main, WT)
